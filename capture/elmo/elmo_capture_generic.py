#!/usr/bin/env python
import os
import random
import struct
import subprocess

import numpy as np
import jinja2

dir = os.path.abspath(os.path.dirname(__file__))

TEMPLATE = open(os.path.join(dir, "elmoprogram.j2")).read()

STDERR_TO_NULL = False


def randbytes(n):
    return [random.randint(0, 255) for _ in range(n)]


def run_elmo(binary="elmo"):
    subprocess.check_call(
        ["rm", "-rf", "output"],
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
        cwd=dir,
    )
    subprocess.check_call(
        [f"./{binary}", "_elmoprogram.bin"],
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
        cwd=dir,
    )


def compile(number_of_traces, input_length, code):
    """Render template with given code and compile using make."""
    template = jinja2.Environment().from_string(TEMPLATE)
    rendered = template.render(dict(number_of_traces=number_of_traces, input_length=input_length, code=code))
    with open(os.path.join(dir, "_elmoprogram.c"), "w") as fp:
        fp.write(rendered)

    additional_args = dict(stderr=subprocess.DEVNULL) if STDERR_TO_NULL is True else {}
    subprocess.check_call(
        ["make", "clean", "all", "BINARY=_elmoprogram"],
        stdout=subprocess.DEVNULL,
        **additional_args,
        cwd=dir,
    )


def trace_length(input_length, code):
    """Estimate number of traces generated by elmo by capturing one shot."""
    compile(number_of_traces=1, input_length=input_length, code=code)

    with open(os.path.join(dir, "plaintexts.txt"), "w") as fp:
        fp.write(input_length * "00\n")

    run_elmo()

    return len(open(os.path.join(dir, "output/asmoutput/asmtrace00001.txt")).read().splitlines()) - 1


def capture(name, number_of_traces, inputfunction, code, cleanup=True, save=True):
    """Capture traces with elmo."""
    input_length = len(inputfunction())
    number_of_samples = trace_length(input_length, code)

    data = np.zeros(
        number_of_traces,
        dtype=[
            ("trace", "f8", number_of_samples),
            ("input", "u1", input_length),
        ],
    )

    compile(number_of_traces=number_of_traces, input_length=input_length, code=code)
    with open(os.path.join(dir, "plaintexts.txt"), "w") as fp:
        for i in range(number_of_traces):
            data["input"][i, :] = inputfunction()
            fp.write("".join(f"{x:02x}\n" for x in data["input"][i, :]))

    run_elmo(binary=name.split("_")[0])

    for i in range(number_of_traces):
        with open(os.path.join(dir, f"output/traces/trace{i + 1:05d}.trc"), "rb") as fp:
            content = fp.read()
        data["trace"][i, :] = struct.unpack(f"{len(content) // 8}d", content)

    if cleanup:
        subprocess.check_call(
            ["rm", "-rf", "output"],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            cwd=dir,
        )

    if save:
        np.save(os.path.join(dir, f"../../data/{name}.npy"), data)
    return data


def main():
    capture(
        "elmo_ldrb_ldrb",
        number_of_traces=10_000,
        inputfunction=lambda: randbytes(2),
        code="""
        asm("movs r0, #0\\n" "movs r1, #0\\n" "movs r2, #0\\n" "movs r3, #0\\n"
            "nop\\n nop\\n nop\\n nop\\n"

            "ldrb r0, [%0]\\n"

            "nop\\n nop\\n nop\\n nop\\n"

            "ldrb r1, [%0, #1]\\n"

            "nop\\n nop\\n nop\\n nop\\n"

            :
            : "r"(input));
            """,
    )


if __name__ == "__main__":
    main()
